# Depth-Frist Search BFS
To overcome the memory limitations of `BFS`, the `DFS` algorithm, uses a *stack* which follows the `LIFO` structure, so `nodes` or `states` are added at the top of the list and it gets rid of the `Visited` set.

## Show me the code ðŸ¤“
The script is [here](Scripts/2_3_DFS.py)

```py
def dfs(start, goal, next_states):
    Stack = [start]
    Parent = {start: start}
    while len(Stack) > 0:
        state = Stack.pop()
        for ns in next_states(state):
            if ns not in Parent:
                Parent[ns] = state
                Stack.append(ns)
            if ns == goal:
                return path_to(start, goal, Parent)
```



## How does it work?



## More Formal Explanation


## Important Information 
- `DFS` is not a complete search. It might get stuck in a long branch or an infinite branch if there is no *cycle checking*.
- Uses much less memory than `BFS` and can find the solution without examining much of the search space.
- `DFS` is not optimal, won't find shortest solutions.
## Recursive Depth-First Search