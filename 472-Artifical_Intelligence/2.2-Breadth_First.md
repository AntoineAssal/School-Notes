# Breadth-Frist Search BFS
`BFS` uses a *queue* which follows the `FIFO` structure, so `nodes` or `states` are added at the end of the list.

## Show me the code ðŸ¤“
The script is [here](Scripts/2_2_BFS.py)

```py
def bfs(start, goal, next_states):
    Frontier = {start}
    Visited = set()
    Parent = {start: start}
    while len(Frontier) > 0:
        NewFrontier = set()
        for s in Frontier:
            for ns in next_states(s):
                if ns not in Visited and ns not in Frontier:
                    NewFrontier.add(ns)
                    Parent[ns] = s
                    if ns == goal:
                        return path_to(goal, Parent)
```



## How does it work?

1. Given the search problem: <img src="https://latex.codecogs.com/png.latex?\dpi{150}&space;\bg_black&space;P&space;=&space;\left&space;\langle&space;Q,&space;next\_states,\:&space;start,\:&space;goal&space;\right&space;\rangle" title="P = \left \langle Q, next\_states,\: start,\: goal \right \rangle" /> we initialize a set `Frontier` to contain the states that have just been discovered but and whose successors have not been visited, so at the beginning `Frontier` contains the state `start`.
2. As long as the set `Frontier` does not contain the state `goal`, we re-run it by adding all the reachable states (that can be reached in one step from a state in Frontier).
3. Then we move the states that have been previously present in `Frontier` to the `Visited` set.
   - This helps us avoid looping. Once a state has been added to `Visited` we never revisit it again.
4. To keep track of the path leading to the goal we use a dictionary called `Parent`.
   - For every state `s` that is in `Frontier`, `Parent[s]` is the state that caused `s` to be added to `Frontier`.

## More Formal Explanation


## 