# Paging
- Paging is a memory-management scheme that permits the physical address space of a process to be non-contiguous.
- Paging avoids the problem of fitting process into memory chunks of various sizes. Most techniques we saw so far suffer from that problem.
  
## Basic Method of Paging
- Break physical memory into fixed-size blocks called frames.
- Break the logical memory (memory of the process) into blocks of the same size called pages.
- When a process is to be executed, its pages are loaded into any available memory frame.

<p align="center">
	<img src="https://i.imgur.com/BKqjktj.jpg" width = "550" alt="Paging">
</p>

- P3 and P4 terminated leaving behind 8 chunks of memory.
- P5 arrives and needs 8 chunks of memory. 
- Usually we wouldn't be able to load it, but since paging allows us to put it in non-contiguous blocks we can load P5.
- Now the question is how will the CPU know which page is located in which frame to load it?
## Page Tables
- Every address generated by the CPU is divided into two parts.
  1. A page nuber `p` - Index of the page table
  2. A page offset `d`- Displacement within the page
- The page table contains the base address of each page in physical memory.
- This base address is combined with the page offset to define the physical memory address that is sent to the memory unit.

<p align="center">
	<img src="https://i.imgur.com/KjwNy8I.png" width = "550" alt="Page table">
</p>

### Translation of Logical Address to Physical Address using Page Table

<p align="center">
	<img src="https://i.imgur.com/bQ7U0um.jpg" width = "550" alt="Page table">
</p>

- Our page size is 4 bytes.
- Our frame size is 4 bytes.
- Physical memory has 8 frames of size 4 bytes so 32 bytes.
- We can see that logical address 0 maps to physical address 20. 
- How do we get there?
  - ((Frame x Page size) + Offset )= ((5x4) + 0) = 20

## Possible Hardware Implementations of Page Table

- Case 1 : Implement the page table as a set of dedicated registers.
  - This can be used only when page table is reasonably small.
  
- Case 2 : Keep the page table in main memory and a page table base register (PTBR) points to the page table.
  - The time required to access a memory location is increadsed as there are two memory accesses needed to access a byte. (one for the page table entry and one for the byte itself)

- Case 3 : Make use of a [Translation Lookaside Buffer](TLB.md)


## Page Table Entries
- Page tables entries contain several information about pages which vary from OS to OS.
- The most important information in a page table entry is the frame number.
- The remaining information is optional

<p align="center">
	<img src="https://i.imgur.com/f98dIDj.png" width = "750" alt="Page table">
</p>

### 1. Frame number
- Frame number denotes the frame where the page is present in the main memory.
- The number of bits required for this depends on the number of frames in the main memory.
- Most important piece of information in the page table entry.
### 2. Present Absent
- One bit (0 or 1) whether the page is present in the main memory or not.
- Also known as valid/invalid bit.
- If its not in the main memory and we need it then we need to find it from the secondary memory (hard drive)
  - If the page we looking for is not present in the main memory that's called a Page Fault
### 3. Protection
- Also known as Read/Write bit, used for page protection.
- It specifies the permissions for read or write operations on the page.
  - Bit is set to 0, if only read is allowed.
  - Bit is set to 1, if both read and write are allowed.
### 4. Reference
- The reference bit specifies whether the page has been referenced in the last clock cycle or not
  - It is set to 1 when the page has been accessed, 0 if not.
### 5. Caching
- The caching bit is used for enabling or disabling caching of the page.
- When we need fresh data we have to disable caching so we avoid fetching of old data from the cache.
- If we want to disable caching, this bit is set to 1, otherwise it is set to 0.
### 6. Dirty
- Also known as the modified bit.
- It specifies whether the page has been modified or not.
- If the page has been modified then this bit is set to 1, otherwise set to 0.
- This bit helps in avoiding unnecessary writes to the secondary memory when a page is being replaced by another page.