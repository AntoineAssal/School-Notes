# Paging
- `Paging` is a `memory-management scheme` that permits the `physical address space` of a `process` to be `non-contiguous`.
- `Paging` avoids the problem of fitting processes into memory chunks of various sizes. Most techniques we saw so far suffer from that problem.
  
## Basic Method of Paging
- Break `physical memory` into fixed-size blocks called `frames`.
- Break the `logical memory` (memory of the process) into blocks of the same size called `pages`.
- When a `process` is to be executed, its `pages` are loaded into any available memory `frame`.

<p align="center">
	<img src="https://i.imgur.com/BKqjktj.jpg" width = "550" alt="Paging">
</p>

- `P3` and `P4` terminated leaving behind `8` chunks of memory.
- `P5` arrives and needs `8` chunks of memory. 
- Usually we wouldn't be able to load it, but since `paging` allows us to put it in `non-contiguous` blocks we can load `P5`.
- Now the question is how will the `CPU` know which `page` is located in which `frame` to load it?
## Page Tables
- Every `address` generated by the `CPU` is divided into two parts.
  1. A page number `p` - Index of the page table
  2. A page offset `d`- Displacement within the page
- The `page table` contains the `base address` of each `page` in `physical memory`.
- This `base address` is combined with the `page offset` to define the `physical memory address` that is sent to the memory unit.

<p align="center">
	<img src="https://i.imgur.com/KjwNy8I.png" width = "550" alt="Page table">
</p>

### Translation of Logical Address to Physical Address using Page Table

<p align="center">
	<img src="https://i.imgur.com/bQ7U0um.jpg" width = "550" alt="Page table">
</p>

- Our `page` size is `4 bytes`.
- Our `frame` size is `4 bytes`.
- `Physical memory` has `8 frames` of size `4 bytes` so `32 bytes`.
- We can see that `logical address` `0` maps to `physical address` `20`. 
- How do we get there?
  - `( (Frame x Page size) + Offset ) = ( (5x4) + 0) = 20`

## Possible Hardware Implementations of Page Table

- Case 1 : Implement the `page table` as a set of dedicated `registers`.
  - This can be used only when `page table` is reasonably small.
  
- Case 2 : Keep the `page table` in `main memory` and a `page table base register (PTBR) `points to the `page table`.
  - The time required to access a memory location is increased as there are two memory accesses needed to access a byte. (one for the page table entry and one for the byte itself)

- Case 3 : Make use of a [Translation Lookaside Buffer](TLB.md)

## Page Table Entries
- `Page tables entries` contain several information about `pages` which vary from `OS` to `OS`.
- The most important information in a p`age table entry` is the `frame number`.
- The remaining information is optional

<p align="center">
	<img src="https://i.imgur.com/f98dIDj.png" width = "750" alt="Page table">
</p>

### 1. Frame number
- `Frame number` denotes the `frame` where the `page` is present in the `main memory`.
- `The number of bits` required for this depends on the number of `frames` in the `main memory`.
- Most important piece of information in the `page table entry`.
### 2. Present Absent
- `One bit (0 or 1)` whether the page is present in the `main memory` or not.
- Also known as valid/invalid bit.
- If its not in the` main memory` and we need it then we need to find it from the `secondary memory (hard drive)`
  - If the `page` we looking for is not present in the `main memory` that's called a `Page Fault`
### 3. Protection
- Also known as `Read/Write bit`, used for `page protection.`
- It specifies the permissions for read or write operations on the `page`.
  - `Bit` is set to `0`, if only read is allowed.
  - `Bit` is set to `1`, if both read and write are allowed.
### 4. Reference
- The reference `bit` specifies whether the `page` has been referenced in the last `clock cycle `or not
  - It is set to `1` when the `page` has been accessed, `0` if not.
### 5. Caching
- The `caching bit` is used for enabling or disabling `caching` of the `page`.
- When we need fresh data we have to disable `caching` so we avoid fetching of old data from the `cache`.
- If we want to disable `caching`, this bit is set to `1`, otherwise it is set to `0`.
### 6. Dirty
- Also known as the `modified bit`.
- It specifies whether the `page` has been modified or not.
- If the `page` has been modified then this `bit` is set to `1`, otherwise set to `0`.
- This `bit` helps in avoiding unnecessary writes to the `secondary memory` when a `page` is being replaced by another `page`.

## Shared Pages
- An advantage of `paging` is the possibility of sharing common code.
- This is particularly important in a `time-sharing environment`.
- If the code is `reentrant` (or `pure`) code, in other words, code that doesn't change itself during execution, then it can be shared among different `processes`.
- However, each `process` has its own copy of `registers` and `data` storage to hold the `data` for the `process`'s execution.
- Therefore, the `data` for different `processes` will of course be different and cannot be shared.
- To illustrate the benefits of using `shared pages`, consider the following example:

A system supports `40` users, each of whom executes a text editor program. If the text editor consists of `150 KB` of code and `50 KB` of `data` space we will need :
- Without `Shared Paging` :` (150x40) + (50x40) = 6000 + 2000 = 8000 KB` to support the `40 users`.
- With `Shared Paging `: `150 + (50x40) = 150+ 2000 = 2150 KB` to support the `40 users`.
  
## Hierarchical Paging
- Most modern computer systems support a large logical address space (`2`<sup>`32`</sup> to `2`<sup>`64`</sup> ).
- In such an environment even the `page table` itself becomes excessively large to store in the `main memory`.

For example consider a system with : 
- `32-bit`` logical addres space`.
- `Page size = 4KB` (`2`<sup>`12`</sup>)
- Then a `page table` may consist of up to (`2`<sup>`32`</sup>`/ 2`<sup>`12`</sup> `= 1 million` entries approx.)
- Assume that each `entry` consists of `4 bytes`.
- So now each `process` may need up to `4 x 1million` `bytes` `= 4MB` of p`hysical address space.`
- Why is this bad?
  - Trying to allocate a `page table` of this size `contiguously` in `main memory` will be hard.
  - What if the `frames` is less than the size required.
- Whats the proposed solution?

### Multi-level Paging
- Use a `two-level paging algorithm`, in which basically the `page table` itself is also `paged`. So we will have an `outer page table` and an `inner page table`.
 
- Reminder this is what we were using before:  
 <p align="center">
	<img src="https://i.imgur.com/JEB2T8a.png" width = "350" alt="Page table">
</p> 

- Now it becomes this: 
 <p align="center">
	<img src="https://i.imgur.com/35HtpFB.png" width = "450" alt="Page table">
</p>

### What is happening / how to read?
- The `CPU` is generating the `logical address`.
- The `logical address` in a` two-level paging` architecture has 3 parts.
  - `p1` = Index of the outer page table.
  - `p2` = Displacement (offset) within the `page` of the `outer page table`.
  - `d` = Displacement (offset) within the `page`, generated by `CPU`.
- So now the `P1`, with the help of our `PTBR` will be looked up in the `outer page table`.
- The `output` that we get from looking up `P1` in the `outer page table` will be combined with `P2` to give us the `input` to look up in the `inner page table`.
- Which will give us the exact `page number` where the `frame` is located.
- That output will be used to form the first part of the `physical address (f)`.
- The `offset (d)` is the same from the `logical address`.
- Now we can find it in `main memory.`

<p align="center">
	<img src="https://i.imgur.com/dpb2xH3.jpg" width = "700" alt="Page table">
</p> 

